<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tile Pairing Interface</title>
    
    <!-- React and ReactDOM -->
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

<style>
    body, html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100vh;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    }

    .btn {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        border: 1px solid #e2e8f0;
        border-radius: 0.375rem;
        background: white;
        cursor: pointer;
        font-size: 0.875rem;
        color: #1a202c;
        transition: all 0.2s;
    }

    .btn:hover {
        background: #f7fafc;
        border-color: #cbd5e0;
    }

    .btn:active {
        background: #edf2f7;
    }

    .btn-sm {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
    }

    .toolbar {
        background: white;
        border-bottom: 1px solid #e2e8f0;
        padding: 0.75rem 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }

    .toolbar-group {
        display: flex;
        gap: 0.75rem;
        align-items: center;
    }

    .zoom-select {
        padding: 0.25rem 0.5rem;
        border: 1px solid #e2e8f0;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        color: #4a5568;
        background: white;
    }

    .zoom-label {
        font-size: 0.875rem;
        color: #718096;
    }

    .canvas {
        background: #f7fafc;
        flex: 1;
    }

    .tile-controls {
        background: white;
        border-radius: 0.375rem;
        padding: 0.25rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
</style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
// Button component
const Button = ({ className = "", children, onClick, variant = "default", size = "default" }) => {
    const baseStyles = "inline-flex items-center justify-center rounded-md font-medium transition-colors";
    const variantStyles = {
        default: "bg-white border border-gray-200 hover:bg-gray-50 text-gray-900",
        outline: "border border-gray-200 bg-transparent hover:bg-gray-100 text-gray-900",
        ghost: "hover:bg-gray-100 text-gray-900"
    };
    const sizeStyles = {
        default: "h-10 px-4 py-2",
        sm: "h-8 px-3 text-sm",
        icon: "h-9 w-9"
    };
    
    return (
        <button
            className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${className}`}
            onClick={onClick}
        >
            {children}
        </button>
    );
};

// Icons component
const Icons = {
    ImagePlus: () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <rect x="3" y="3" width="18" height="18" rx="2"/>
            <path d="M12 8v8m-4-4h8"/>
        </svg>
    ),
    RotateCw: () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.7 2.8L21 8"/>
        </svg>
    ),
    RotateCcw: () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <path d="M3 12a9 9 0 1 1 9 9c-2.52 0-4.93-1-6.7-2.8L3 16"/>
        </svg>
    ),
    FlipHorizontal: () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <path d="M8 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h3m8-18h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3m-4-1V3"/>
        </svg>
    ),
	Flip: () => (
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <path d="M7 16h10M7 8h10M12 4v16"/>
    </svg>
	),
	Delete: () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
            <line x1="10" y1="11" x2="10" y2="17"/>
            <line x1="14" y1="11" x2="14" y2="17"/>
        </svg>
    )
	
	
	
};




const TilePairingInterface = () => {
    const [tiles, setTiles] = React.useState([]);
    const [isFlipped, setIsFlipped] = React.useState(false);
    const [draggedTile, setDraggedTile] = React.useState(null);
    const [dragOffset, setDragOffset] = React.useState({ x: 0, y: 0 });
    const [viewBox, setViewBox] = React.useState({ x: 0, y: 0, width: 1200, height: 800 });
    const [isPanning, setIsPanning] = React.useState(false);
    const [lastMousePosition, setLastMousePosition] = React.useState({ x: 0, y: 0 });
    const svgRef = React.useRef(null);

    const tilePath = "M93.075588,186.263531L94.568682,74.654722l63.456514-.373275L190.5,19.036953L286.058044,73.5349l-.373274,110.488989l63.829788.746547L381,240.761477l-95.688503,54.497947L190.5,240.761476l-31.728257,54.124673-129.152669-.000001L0,240.761476l93.075588-54.497945Z";
    const centerX = 190.5;
    const centerY = 147.5;

    const handleWheel = (e) => {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
        
        const svgRect = svgRef.current.getBoundingClientRect();
        const mouseX = e.clientX - svgRect.left;
        const mouseY = e.clientY - svgRect.top;
        
        const pointX = viewBox.x + (mouseX / svgRect.width) * viewBox.width;
        const pointY = viewBox.y + (mouseY / svgRect.height) * viewBox.height;
        
        setViewBox(vb => ({
            x: pointX - (pointX - vb.x) * zoomFactor,
            y: pointY - (pointY - vb.y) * zoomFactor,
            width: vb.width * zoomFactor,
            height: vb.height * zoomFactor
        }));
    };

    const handleMouseDown = (e) => {
        if (e.button === 1 || e.button === 2) {
            e.preventDefault();
            setIsPanning(true);
            setLastMousePosition({
                x: e.clientX,
                y: e.clientY
            });
        }
    };

    const handleMouseMove = (e) => {
        if (draggedTile) {
            const svgElement = svgRef.current;
            const pt = svgElement.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(svgElement.getScreenCTM().inverse());

            // Adjust position based on field flip state
            const adjustedX = isFlipped ? viewBox.width - svgP.x : svgP.x;

            setTiles(tiles.map(tile => 
                tile.id === draggedTile.id
                    ? { 
                        ...tile, 
                        x: adjustedX - dragOffset.x,
                        y: svgP.y - dragOffset.y 
                    }
                    : tile
            ));
        } else if (isPanning) {
            const dx = e.clientX - lastMousePosition.x;
            const dy = e.clientY - lastMousePosition.y;
            
            const scale = viewBox.width / svgRef.current.clientWidth;
            
            setViewBox(vb => ({
                ...vb,
                x: vb.x - dx * scale,
                y: vb.y - dy * scale
            }));
            
            setLastMousePosition({
                x: e.clientX,
                y: e.clientY
            });
        }
    };

    const handleMouseUp = () => {
        setIsPanning(false);
        setDraggedTile(null);
    };

    const resetView = () => {
        setViewBox({ x: 0, y: 0, width: 1200, height: 800 });
    };

	const deleteTile = (tileId) => {
    setTiles(tiles.filter(tile => tile.id !== tileId));
};

    const addTilePair = () => {
        setTiles([...tiles, {
            id: Date.now(),
            front: null,
            back: null,
            x: Math.random() * 800,
            y: Math.random() * 600,
            rotation: 0,
            isMirrored: false,
			isFlippedIndividually: false,
        }]);
    };

    const rotateTile = (tileId, direction) => {
        setTiles(tiles.map(tile => 
            tile.id === tileId
                ? { ...tile, rotation: tile.rotation + (direction * 15) }
                : tile
        ));
    };

    const mirrorTile = (tileId) => {
        setTiles(tiles.map(tile => 
            tile.id === tileId
                ? { ...tile, isMirrored: !tile.isMirrored }
                : tile
        ));
    };

    const handleImageSelect = (e, tileId, side) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                setTiles(tiles.map(tile =>
                    tile.id === tileId
                        ? { ...tile, [side]: e.target.result }
                        : tile
                ));
            };
            reader.readAsDataURL(file);
        }
    };

    const handleTileDragStart = (e, tile) => {
        e.stopPropagation();
        const svgElement = svgRef.current;
        const pt = svgElement.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgElement.getScreenCTM().inverse());
        
        // Adjust drag offset based on field flip state
        const adjustedX = isFlipped ? viewBox.width - svgP.x : svgP.x;
        
        setDraggedTile(tile);
        setDragOffset({
            x: adjustedX - tile.x,
            y: svgP.y - tile.y
        });
    };

 const getTileTransform = (tile) => {
    // First transform to centered coordinates
    const centerPosX = tile.x + centerX;
    const centerPosY = tile.y + centerY;
    
    // If the field is flipped, mirror the x position across the center of the viewBox
    const flippedX = isFlipped ? viewBox.width - centerPosX : centerPosX;
    
    return `
        translate(${flippedX}, ${centerPosY})
        rotate(${isFlipped ? -tile.rotation : tile.rotation})
        scale(${tile.isMirrored ? -1 : 1}, 1)
        translate(${-centerX}, ${-centerY})
    `;
};

    // Flip the entire view when toggling
    const handleFlip = () => {
        setIsFlipped(!isFlipped);
        // Mirror the viewBox's x position when flipping
        setViewBox(vb => ({
            ...vb,
            x: vb.width - vb.x - vb.width // This mirrors the viewBox position
        }));
    };
	
	
	   
const saveToFile = () => {
    const saveData = {
        tiles: tiles.map(tile => ({
            ...tile,
            // Convert base64 images to shorter preview URLs if needed
            front: tile.front ? 'image_saved' : null,
            back: tile.back ? 'image_saved' : null
        })),
        isFlipped,
        viewBox
    };
    
    const blob = new Blob([JSON.stringify(saveData)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `tile-layout-${new Date().toISOString().slice(0,10)}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};

    const loadFromFile = (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const saveData = JSON.parse(e.target.result);
                    setTiles(saveData.tiles);
                    setIsFlipped(saveData.isFlipped);
                    setViewBox(saveData.viewBox);
                } catch (err) {
                    alert('Error loading save file');
                }
            };
            reader.readAsText(file);
        }
    };
	
	
		

    React.useEffect(() => {
        const preventDefault = (e) => e.preventDefault();
        svgRef.current?.addEventListener('contextmenu', preventDefault);
        return () => svgRef.current?.removeEventListener('contextmenu', preventDefault);
    }, []);

	const BulkUploadButton = ({ onTilesCreated }) => {
    const handleFolderUpload = async (e) => {
        const files = Array.from(e.target.files);
        const imageMap = new Map();

        // Group files by their base name (without _obverse/_reverse)
        files.forEach(file => {
            const match = file.name.match(/(.+?)_(obverse|reverse)\.png$/);
            if (match) {
                const [, baseId, side] = match;
                if (!imageMap.has(baseId)) {
                    imageMap.set(baseId, {});
                }
                
                // Convert file to data URL
                const reader = new FileReader();
                reader.readAsDataURL(file);
                
                reader.onload = () => {
                    imageMap.get(baseId)[side === 'obverse' ? 'front' : 'back'] = reader.result;
                    
                    // Check if both sides are loaded
                    const currentTile = imageMap.get(baseId);
                    if (currentTile.front && currentTile.back) {
                        createTile(baseId, currentTile);
                    }
                };
            }
        });

        // Create a tile with both images
        const createTile = (baseId, images) => {
            const newTile = {
                id: baseId,
                front: images.front,
                back: images.back,
                x: Math.random() * 800,
                y: Math.random() * 600,
                rotation: 0,
                isMirrored: false,
				isFlippedIndividually: false
            };

            onTilesCreated(newTile);
        };
    };

    return (
        <label className="btn">
            <input
                type="file"
                multiple
                webkitdirectory=""
                directory=""
                style={{ display: 'none' }}
                onChange={handleFolderUpload}
            />
            Bulk Upload Folder
        </label>
    );
};

const handleBulkTilesCreated = (newTile) => {
    setTiles(prevTiles => [...prevTiles, newTile]);
};

const flipTile = (tileId) => {
    setTiles(tiles.map(tile => 
        tile.id === tileId
            ? { ...tile, isFlippedIndividually: !tile.isFlippedIndividually }
            : tile
    ));
};


    return (
 <div className="w-full h-screen flex flex-col">
    <div className="toolbar">
        <div className="toolbar-group">
            <Button onClick={addTilePair}>
                <Icons.ImagePlus /> New Tile
            </Button>
            <BulkUploadButton onTilesCreated={handleBulkTilesCreated} />
            <Button onClick={handleFlip}>
                <Icons.RotateCcw /> Flip Field
            </Button>
        </div>
        
        <div className="toolbar-group">
            <Button onClick={saveToFile}>Save Layout</Button>
            <label className="btn">
                Load Layout
                <input
                    type="file"
                    accept=".json"
                    onChange={loadFromFile}
                    style={{ display: 'none' }}
                />
            </label>
            <Button onClick={resetView}>Reset View</Button>
            
            <div className="flex items-center gap-2">
                <select 
                    className="zoom-select"
                    value={Math.round(1200/viewBox.width * 100)}
                    onChange={(e) => {
                        const zoom = parseInt(e.target.value) / 100;
                        setViewBox(vb => ({
                            ...vb,
                            width: 1200 / zoom,
                            height: 800 / zoom
                        }));
                    }}
                >
                    <option value="25">25%</option>
                    <option value="50">50%</option>
                    <option value="75">75%</option>
                    <option value="100">100%</option>
                    <option value="150">150%</option>
                    <option value="200">200%</option>
                </select>
                <span className="zoom-label">
                    Zoom: {Math.round(1200/viewBox.width * 100)}%
                </span>
            </div>
        </div>
    </div>

    <svg 
        ref={svgRef}
        className="canvas"
        onWheel={handleWheel}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        viewBox={`${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`}
        preserveAspectRatio="xMidYMid meet"
    >
                <defs>
                    {tiles.map((tile) => (
                        <React.Fragment key={`patterns-${tile.id}`}>
                            <pattern
                                id={`front-${tile.id}`}
                                patternUnits="userSpaceOnUse"
                                width="381"
                                height="295"
								patternTransform={`scale(${tile.isMirrored ? -1 : 1}, 1)`}
                            >
                                {tile.front ? (
                                    <image
                                        href={tile.front}
                                        width="381"
                                        height="295"
                                        preserveAspectRatio="xMidYMid slice"
                                    />
                                ) : (
                                    <rect width="381" height="295" fill="#f0f0f0" />
                                )}
                            </pattern>
                            <pattern
                                id={`back-${tile.id}`}
                                patternUnits="userSpaceOnUse"
                                width="381"
                                height="295"
								patternTransform={`scale(${tile.isMirrored ? -1 : 1}, 1)`}
                            >
                                {tile.back ? (
                                    <image
                                        href={tile.back}
                                        width="381"
                                        height="295"
                                        preserveAspectRatio="xMidYMid slice"
                                    />
                                ) : (
                                    <rect width="381" height="295" fill="#e0e0e0" />
                                )}
                            </pattern>
                        </React.Fragment>
                    ))}
                </defs>

                {tiles.map((tile) => (
                    <g
                        key={tile.id}
                        transform={getTileTransform(tile)}
                        onMouseDown={(e) => handleTileDragStart(e, tile)}
                        style={{ cursor: 'move' }}
                    >
                        <path
							d={tilePath}
							fill={`url(#${(isFlipped !== tile.isFlippedIndividually) ? 'front' : 'back'}-${tile.id})`}
							stroke="black"
							strokeWidth="1"
                        />
                        {!tile[isFlipped ? 'back' : 'front'] && (
                            <foreignObject x="140" y="120" width="100" height="40">
                                <div style={{ display: 'flex', justifyContent: 'center' }}>
                                    <input
                                        type="file"
                                        accept="image/*"
                                        onChange={(e) => handleImageSelect(e, tile.id, isFlipped ? 'back' : 'front')}
                                        style={{ width: '100%', height: '100%', opacity: 0, cursor: 'pointer', position: 'absolute' }}
                                    />
                                    <span style={{ color: '#666' }}>
                                        {isFlipped ? 'Add Back' : 'Add Front'}
                                    </span>
                                </div>
                            </foreignObject>
                        )}
                        <foreignObject x="100" y="240" width="180" height="40">
    <div style={{ display: 'flex', justifyContent: 'center', gap: '0.5rem' }}>
        <Button 
            onClick={(e) => {
                e.stopPropagation();
                rotateTile(tile.id, -1);
            }}
            className="btn-sm"
        >
            <Icons.RotateCcw />
        </Button>
		<Button 
    onClick={(e) => {
        e.stopPropagation();
        flipTile(tile.id);
    }}
    className="btn-sm"
>
    <Icons.Flip />
</Button>
        <Button 
            onClick={(e) => {
                e.stopPropagation();
                rotateTile(tile.id, 1);
            }}
            className="btn-sm"
        >
            <Icons.RotateCw />
        </Button>
        <Button 
            onClick={(e) => {
                e.stopPropagation();
                mirrorTile(tile.id);
            }}
            className="btn-sm"
        >
            <Icons.FlipHorizontal />
        </Button>
        <Button 
            onClick={(e) => {
                e.stopPropagation();
                deleteTile(tile.id);
            }}
            className="btn-sm"
        >
            <Icons.Delete />
        </Button>
    </div>
</foreignObject>
                    </g>
                ))}
            </svg>
        </div>
    );
};


        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TilePairingInterface />);
    </script>
</body>
</html>